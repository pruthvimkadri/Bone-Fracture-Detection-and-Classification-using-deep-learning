ğŸ¦´ Bone Fracture Detection and Classification using Deep Learning & Computer Vision
ğŸ“Œ Project Overview
Bone fractures are one of the most common medical injuries. Detecting and identifying fracture types manually from X-rays is time-consuming and requires expert radiologists.
This project introduces an AI-powered Flask web application that can:

âœ… Validate whether the uploaded image is a real bone X-ray
âœ… Detect if a fracture exists (Binary Classification)
âœ… Classify the fracture into 11 different medical fracture types
âœ… Generate AI-assisted heatmap visualizations (Grad-CAM like output + Canny Edge hybrid for learning)
âœ… Store user results and reports for later reference
âœ… Be deployed to the cloud using Render + Gunicorn WSGI server

ğŸ§  How the System Works (Backend Logic)

User uploads an image via the Web UI

App runs X-ray validation

If valid X-ray âœ… â†’ fracture detection is executed using PyTorch model

If fracture detected âœ… â†’ multiclass classifier identifies fracture type among 11 classes

Output images + analysis reports are saved in:

backend/static/uploads/


Users can view:

Original image

Canny Edge result

AI heatmap overlay

Hybrid visualization

Classification confidence

ğŸ—‚ï¸ Folder Structure
Bone-Fracture-Detection-and-Classification/
â”‚
â”œâ”€â”€ Homees/
â”‚   â”œâ”€â”€ main.py                     â† Flask application
â”‚   â”œâ”€â”€ wsgi.py                     â† WSGI entry point for deployment
â”‚   â”œâ”€â”€ download_models.py           â† Used to download models in cloud before server starts
â”‚   â”œâ”€â”€ requirements.txt             â† Dependencies list
â”‚   â”œâ”€â”€ static/
â”‚   â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”œâ”€â”€ js/
â”‚   â”‚   â”œâ”€â”€ models/                  â† Empty placeholder (models will be downloaded in cloud)
â”‚   â”‚   â””â”€â”€ uploads/                 â† Empty folder (results stored here in deployed builds)
â”‚   â””â”€â”€ templates/
â”‚
â”œâ”€â”€ .gitignore                      â† Prevents large model files from being pushed
â””â”€â”€ README.md                       â† Project documentation (this file)

ğŸ”§ Tech Stack
Component	Technology
Backend Server	Flask (Python)
Model Serving	PyTorch (.pt, .pth)
Image Processing	OpenCV, NumPy
Deployment	Gunicorn, Render Cloud
Storage (optional)	MongoDB, SQLite
Frontend UI	HTML, CSS, JavaScript
â˜ï¸ Deployment Status

Hosted on Render Free Web Service (512MB RAM limit)

Models are auto-downloaded at build time from Hugging Face

Server runs using:

gunicorn wsgi:app


Live application URL: ğŸ‰ (auto generated by render at deploy)

ğŸš« .gitignore Rules Applied

Large model files and local env configs are ignored for GitHub using:

*.pt
*.pt
*.pt
.env
static/models/
static/uploads/
__pycache__/
.venv/

ğŸ¯ Key Features

AI classification trained on bone fracture datasets

Supports 11 fracture types

Confidence score for each prediction

Educational hybrid output visuals

Report generation for uploads

Login system & stored result history

Ready for cloud hosting

ğŸ“š Learnings / Outcomes

Through this project we gained hands-on experience in:

âœ” Deploying ML models on cloud efficiently
âœ” Using OpenCV for edge-based validations
âœ” Model inference using PyTorch in low-resource environments
âœ” Flask backend routing + UI integration
âœ” Hosting scalable web services using Gunicorn WSGI
âœ” Managing large ML models using GitHub ignore + cloud download strategy

ğŸ›  Installation Guide (Local Setup)
git clone <your-repo-link>
cd Homees/
pip install -r requirements.txt
python main.py

â–¶ Running the App on Cloud

The app is hosted using Render build command:

pip install -r requirements.txt && python download_models.py


Gunicorn automatically starts using:

gunicorn wsgi:app


Image Preprocessing & Enhancements

Canny Edge & Dataset Handling

Fracture Detection Model Training (PyTorch)

Model Testing & Evaluation

UI & Cloud Deployment

â­ Future Enhancements

Add 3D fracture detection pipeline

Deploy mobile inference using TensorFlow Lite

Add REST API for hospital integration

Use doctor feedback for continual learning
